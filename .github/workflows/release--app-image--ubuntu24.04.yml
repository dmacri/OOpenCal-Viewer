name: Build Qt-VTK Viewer AppImage

on:
  push:
    branches:
      - '**'
  release:
    types: [created]

env:
  PROJECT_NAME: OOpenCal-Viewer

jobs:
  build:
    runs-on: ubuntu-24.04

    steps:
      ################### checkout & dependencies ###################
      - name: Checkout main repository
        uses: actions/checkout@v3

      - name: Checkout OOpenCAL dependency
        uses: actions/checkout@v3
        with:
          repository: alessioderango/OOpenCAL
          path: deps/OOpenCAL
          token: ${{ secrets.VisualizerOpenCal }}

      ################### environment & build tools ###################
      - name: Install build prerequisites
        run: |
          sudo apt update
          sudo apt install -y --no-install-recommends \
            build-essential \
            cmake \
            ninja-build \
            qtbase5-dev \
            qttools5-dev \
            qttools5-dev-tools \
            libvtk9-dev \
            libvtk9-qt-dev \
            libfreetype-dev \
            libeigen3-dev \
            libtiff-dev \
            libpng-dev \
            libjpeg-dev \
            zlib1g-dev \
            libgl1-mesa-dev \
            libglu1-mesa-dev \
            patchelf \
            file \
            wget

      - name: Download and extract static-clang toolchain
        run: |
          # Create temporary directories
          mkdir -p /tmp/appimage-headers
          mkdir -p /tmp/clang-binaries
          
          # Download static-clang v17.0.6 (pre-built with all dependencies)
          echo "Downloading static-clang v17.0.6..."
          CLANG_URL="https://github.com/dzbarsky/static-clang/releases/download/v17.0.6-10/linux_amd64.tar.zst"
          
          wget -q "$CLANG_URL" -O /tmp/clang.tar.zst || {
            echo "Failed to download static-clang"
            exit 1
          }
          
          echo "Extracting static-clang..."
          cd /tmp
          tar -xf clang.tar.zst || {
            echo "Failed to extract clang archive"
            exit 1
          }
          
          CLANG_DIR="/tmp/linux_amd64"
          
          if [ ! -d "$CLANG_DIR" ]; then
            echo "ERROR: Clang directory not found at $CLANG_DIR"
            ls -la /tmp/ | grep -E "linux|clang|LLVM"
            exit 1
          fi
          
          echo "✓ Found clang at: $CLANG_DIR"
          
          # Copy clang binaries
          echo "Copying clang binaries..."
          mkdir -p /tmp/clang-binaries/bin
          cp "$CLANG_DIR/bin/clang++" /tmp/clang-binaries/bin/ || true
          cp "$CLANG_DIR/bin/clang" /tmp/clang-binaries/bin/ || true
          cp "$CLANG_DIR/bin/clang-cpp" /tmp/clang-binaries/bin/ || true
          chmod +x /tmp/clang-binaries/bin/clang* 2>/dev/null || true
          echo "✓ Clang binaries copied"
          
          # Copy all clang libraries
          echo "Copying clang libraries..."
          mkdir -p /tmp/clang-binaries/lib
          if [ -d "$CLANG_DIR/lib" ]; then
            cp -rv "$CLANG_DIR/lib"/* /tmp/clang-binaries/lib/ 2>&1 | head -20
            echo "✓ Clang libraries copied"
          fi
          
          # Copy all headers (C++, C, intrinsics)
          echo "Copying all headers to temporary location..."
          
          # Copy C++ headers (libc++)
          if [ -d "$CLANG_DIR/include/c++/v1" ]; then
            mkdir -p /tmp/appimage-headers/include/c++/v1
            cp -rv "$CLANG_DIR/include/c++/v1"/* /tmp/appimage-headers/include/c++/v1/ 2>&1 | head -20
            echo "✓ C++ headers copied"
          fi
          
          # Copy clang intrinsics and C headers
          if [ -d "$CLANG_DIR/lib/clang/17/include" ]; then
            mkdir -p /tmp/appimage-headers/lib/clang/17/include
            cp -rv "$CLANG_DIR/lib/clang/17/include"/* /tmp/appimage-headers/lib/clang/17/include/ 2>&1 | head -20
            echo "✓ Clang intrinsics headers copied"
          fi
          
          echo "✓ Static-clang toolchain prepared"
          rm -f /tmp/clang.tar.zst
          
          echo "✓ Static-clang toolchain ready with all headers"

      ################### build application ###################
      - name: Configure CMake
        run: |
          mkdir -p build
          cd build
          
          # Set CLANG_TOOLCHAIN_PATH for plugin compilation (runtime)
          # but use system compiler for building the application
          CLANG_TOOLCHAIN_PATH="${GITHUB_WORKSPACE}/AppDir/usr/bin"
          
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DOOPENCAL_DIR=${{ github.workspace }}/deps \
            -DCMAKE_INSTALL_PREFIX=/usr \
            -DCLANG_TOOLCHAIN_PATH="$CLANG_TOOLCHAIN_PATH"

      - name: Build application
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Install to temporary directory
        run: |
          cd build
          DESTDIR=${{ github.workspace }}/AppDir cmake --install .

      ################### prepare AppDir structure ###################
      - name: Create AppDir structure
        run: |
          mkdir -p AppDir/usr/bin
          mkdir -p AppDir/usr/lib
          mkdir -p AppDir/usr/share/applications
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
          mkdir -p AppDir/usr/include

          # Copy main executable
          cp build/${PROJECT_NAME} AppDir/usr/bin/ || \
          cp AppDir/usr/bin/${PROJECT_NAME} AppDir/usr/bin/ || true

      - name: Copy VTK headers to temporary location
        run: |
          echo "Copying VTK headers to temporary location..."
          
          # Find VTK headers
          VTK_INCLUDE_DIR=$(find /usr/include -maxdepth 1 -name "vtk*" -type d 2>/dev/null | head -1)
          if [ -n "$VTK_INCLUDE_DIR" ]; then
            echo "Found VTK headers at: $VTK_INCLUDE_DIR"
            mkdir -p /tmp/appimage-headers/include
            cp -rv "$VTK_INCLUDE_DIR" /tmp/appimage-headers/include/ 2>&1 | head -20
            echo "✓ VTK headers copied to temporary location"
            
            # Verify key VTK headers
            VTK_DIR_NAME=$(basename "$VTK_INCLUDE_DIR")
            if [ -f "/tmp/appimage-headers/include/$VTK_DIR_NAME/vtkRenderer.h" ]; then
              echo "✓ vtkRenderer.h found in temporary location"
            fi
          else
            echo "⚠ VTK headers not found in /usr/include"
            echo "Available include directories:"
            ls -d /usr/include/vtk* 2>/dev/null || echo "No vtk* directories found"
          fi

      - name: Copy bundled headers from temporary location
        run: |
          echo "Copying bundled headers from temporary location to AppDir..."
          
          # Copy musl and system headers
          if [ -d "/tmp/appimage-headers/include" ]; then
            echo "Copying include headers..."
            cp -rv /tmp/appimage-headers/include/* AppDir/usr/include/ 2>&1 | head -20
            if [ -f "AppDir/usr/include/stddef.h" ]; then
              echo "✓ stddef.h successfully copied to AppDir"
            else
              echo "✗ stddef.h NOT in AppDir after copy!"
            fi
            
            # CRITICAL: Verify bits/alltypes.h was copied
            if [ -f "AppDir/usr/include/bits/alltypes.h" ]; then
              echo "✓ bits/alltypes.h successfully copied to AppDir"
            else
              echo "✗ bits/alltypes.h NOT in AppDir after copy!"
              echo "Checking if bits/ directory exists in /tmp/appimage-headers/include:"
              ls -la /tmp/appimage-headers/include/bits/ 2>/dev/null | head -10 || echo "bits/ directory not found in /tmp/appimage-headers/include"
              echo "Checking if bits/ directory exists in AppDir/usr/include:"
              ls -la AppDir/usr/include/bits/ 2>/dev/null | head -10 || echo "bits/ directory not found in AppDir/usr/include"
            fi
          fi
          
          # Copy clang intrinsics headers
          if [ -d "/tmp/appimage-headers/lib/clang" ]; then
            echo "Copying clang intrinsics headers..."
            mkdir -p AppDir/usr/lib/clang
            cp -rv /tmp/appimage-headers/lib/clang/* AppDir/usr/lib/clang/ 2>&1 | head -20
            if [ -f "AppDir/usr/lib/clang/21/include/stddef.h" ]; then
              echo "✓ stddef.h in clang headers successfully copied"
            fi
          fi
          
          # Copy GCC headers
          if [ -d "/tmp/appimage-headers/lib/gcc" ]; then
            echo "Copying GCC headers..."
            mkdir -p AppDir/usr/lib/gcc
            cp -rv /tmp/appimage-headers/lib/gcc/* AppDir/usr/lib/gcc/ 2>&1 | head -20
          fi
          
          echo "Bundled headers copied successfully"

      - name: Copy clang binaries and libraries from temporary location
        run: |
          echo "Copying clang binaries and libraries from temporary location..."
          
          # Copy clang binaries
          if [ -d "/tmp/clang-binaries/bin" ]; then
            echo "Copying clang binaries..."
            mkdir -p AppDir/usr/bin
            cp -v /tmp/clang-binaries/bin/clang++ AppDir/usr/bin/ || true
            cp -v /tmp/clang-binaries/bin/clang AppDir/usr/bin/ || true
            cp -v /tmp/clang-binaries/bin/clang-cpp AppDir/usr/bin/ || true
            chmod +x AppDir/usr/bin/clang++ AppDir/usr/bin/clang 2>/dev/null || true
            echo "✓ Clang binaries copied"
          fi
          
          # Copy clang libraries
          if [ -d "/tmp/clang-binaries/lib" ]; then
            echo "Copying clang libraries..."
            mkdir -p AppDir/usr/lib/clang-libs
            cp -rv /tmp/clang-binaries/lib/* AppDir/usr/lib/clang-libs/ 2>&1 | head -20
            echo "✓ Clang libraries copied"
          fi
          
          # Verify clang is in AppDir
          if [ -f "AppDir/usr/bin/clang++" ]; then
            echo "✓ clang++ found in AppDir"
            ls -lh AppDir/usr/bin/clang++
          else
            echo "✗ clang++ NOT found in AppDir!"
          fi

      - name: Copy precompiled header and project headers
        run: |
          # Create all necessary include directories
          mkdir -p AppDir/usr/include/utilities
          mkdir -p AppDir/usr/include/visualiser
          mkdir -p AppDir/usr/include/visualiserProxy
          mkdir -p AppDir/usr/include/config
          mkdir -p AppDir/usr/include/widgets

          # Copy precompiled header if it exists
          if [ -f "build/include/SceneWidgetVisualizer.pch.gch" ]; then
            cp build/include/SceneWidgetVisualizer.pch.gch AppDir/usr/include/ || true
            echo "Precompiled header copied successfully"
          else
            echo "Warning: Precompiled header not found at build/include/SceneWidgetVisualizer.pch.gch"
          fi

          # Copy precompiled header source
          if [ -f "visualiserProxy/SceneWidgetVisualizer.pch.h" ]; then
            cp visualiserProxy/SceneWidgetVisualizer.pch.h AppDir/usr/include/ || true
          fi

          # Copy all headers from utilities/
          if [ -d "utilities" ]; then
            cp -r utilities/*.h AppDir/usr/include/utilities/ 2>/dev/null || true
            cp -r utilities/*.hpp AppDir/usr/include/utilities/ 2>/dev/null || true
          fi

          # Copy all headers from visualiser/
          if [ -d "visualiser" ]; then
            cp -r visualiser/*.h AppDir/usr/include/visualiser/ 2>/dev/null || true
            cp -r visualiser/*.hpp AppDir/usr/include/visualiser/ 2>/dev/null || true
          fi

          # Copy all headers from visualiserProxy/
          if [ -d "visualiserProxy" ]; then
            cp -r visualiserProxy/*.h AppDir/usr/include/visualiserProxy/ 2>/dev/null || true
            cp -r visualiserProxy/*.hpp AppDir/usr/include/visualiserProxy/ 2>/dev/null || true
          fi

          # Copy all headers from config/
          if [ -d "config" ]; then
            cp -r config/*.h AppDir/usr/include/config/ 2>/dev/null || true
            cp -r config/*.hpp AppDir/usr/include/config/ 2>/dev/null || true
          fi

          # Copy all headers from widgets/
          if [ -d "widgets" ]; then
            cp -r widgets/*.h AppDir/usr/include/widgets/ 2>/dev/null || true
            cp -r widgets/*.hpp AppDir/usr/include/widgets/ 2>/dev/null || true
          fi

          echo "Project headers copied successfully"

      - name: Copy VTK headers
        run: |
          # Copy VTK headers
          if [ -d "/usr/include/vtk-9.1" ]; then
            mkdir -p AppDir/usr/include/vtk
            cp -r /usr/include/vtk-9.1/* AppDir/usr/include/vtk/ || true
          elif [ -d "/usr/include/vtk" ]; then
            cp -r /usr/include/vtk AppDir/usr/include/ || true
          fi

      - name: Copy Qt libraries
        run: |
          # Find Qt library path
          QT_LIB_PATH=$(qmake -query QT_INSTALL_LIBS)

          # Copy essential Qt libraries
          for lib in Core Gui Widgets OpenGL DBus XcbQpa; do
            cp -P ${QT_LIB_PATH}/libQt5${lib}.so* AppDir/usr/lib/ || true
          done

          # Copy Qt plugins
          QT_PLUGINS=$(qmake -query QT_INSTALL_PLUGINS)
          mkdir -p AppDir/usr/plugins
          cp -r ${QT_PLUGINS}/platforms AppDir/usr/plugins/ || true
          cp -r ${QT_PLUGINS}/xcbglintegrations AppDir/usr/plugins/ || true
          cp -r ${QT_PLUGINS}/imageformats AppDir/usr/plugins/ || true

      - name: Copy VTK libraries
        run: |
          # Find and copy VTK libraries
          VTK_LIBS=$(find /usr/lib/x86_64-linux-gnu -name "libvtk*.so*" -type f)
          for lib in $VTK_LIBS; do
            cp -P $lib AppDir/usr/lib/ || true
            # Also copy symlinks
            if [ -L $lib ]; then
              cp -d $lib AppDir/usr/lib/ || true
            fi
          done

          # Copy VTK dependencies
          for lib in /usr/lib/x86_64-linux-gnu/libvtk*.so*; do
            [ -e "$lib" ] && cp -P "$lib" AppDir/usr/lib/ || true
          done

      - name: Copy system dependencies
        run: |
          # Function to copy library and its dependencies
          copy_deps() {
            local binary=$1
            ldd "$binary" 2>/dev/null | grep "=> /" | awk '{print $3}' | while read lib; do
              if [ -f "$lib" ]; then
                # Skip system libraries that should be on every system
                case "$lib" in
                  /lib/x86_64-linux-gnu/libc.so*|\
                  /lib/x86_64-linux-gnu/libm.so*|\
                  /lib/x86_64-linux-gnu/libdl.so*|\
                  /lib/x86_64-linux-gnu/libpthread.so*|\
                  /lib/x86_64-linux-gnu/librt.so*|\
                  /lib/x86_64-linux-gnu/ld-linux*.so*)
                    continue
                    ;;
                esac
                cp -n "$lib" AppDir/usr/lib/ 2>/dev/null || true
              fi
            done
          }

          # Copy dependencies for main executable
          copy_deps "AppDir/usr/bin/${PROJECT_NAME}"

          # Copy dependencies for Qt and VTK libraries
          for lib in AppDir/usr/lib/*.so*; do
            [ -f "$lib" ] && copy_deps "$lib"
          done

      ################### icons and desktop entry ###################
      - name: Prepare application icon
        run: |
          if [ -f icons/application.png ]; then
            cp icons/application.png AppDir/usr/share/icons/hicolor/256x256/apps/${PROJECT_NAME}.png
            cp icons/application.png AppDir/${PROJECT_NAME}.png
          else
            # Create a dummy icon if none exists
            convert -size 256x256 xc:blue AppDir/${PROJECT_NAME}.png
            cp AppDir/${PROJECT_NAME}.png AppDir/usr/share/icons/hicolor/256x256/apps/${PROJECT_NAME}.png
          fi

      - name: Create .desktop file
        run: |
          cat > AppDir/${PROJECT_NAME}.desktop << EOF
          [Desktop Entry]
          Name=${PROJECT_NAME}
          Exec=${PROJECT_NAME}
          Icon=${PROJECT_NAME}
          Type=Application
          Categories=Utility;Science;
          EOF

          cp AppDir/${PROJECT_NAME}.desktop AppDir/usr/share/applications/

      - name: Create AppRun script
        run: |
          cat > AppDir/AppRun << EOF
          #!/bin/bash
          SELF=\$(readlink -f "\$0")
          HERE=\${SELF%/*}

          # Set up library path for Qt and other libraries
          # (clang++ will use RPATH to find its own libraries)
          export LD_LIBRARY_PATH="\${HERE}/usr/lib:\${LD_LIBRARY_PATH}"

          # Set up Qt plugin path
          export QT_PLUGIN_PATH="\${HERE}/usr/plugins"
          export QT_QPA_PLATFORM_PLUGIN_PATH="\${HERE}/usr/plugins/platforms"

          # Set OOPENCAL_VIEWER_ROOT to point to AppImage include directory
          export OOPENCAL_VIEWER_ROOT="\${HERE}/usr/include"

          # Set PRECOMPILED_HEADER_PATH for plugin compilation
          export PRECOMPILED_HEADER_PATH="\${HERE}/usr/include"

          # Set clang toolchain path for plugin compilation
          export CLANG_TOOLCHAIN_PATH="\${HERE}/usr/bin"

          # Disable Qt's automatic high DPI scaling (user can set QT_AUTO_SCREEN_SCALE_FACTOR=1 if needed)
          export QT_AUTO_SCREEN_SCALE_FACTOR=0

          # Execute the application
          exec "\${HERE}/usr/bin/${PROJECT_NAME}" "\$@"
          EOF

          chmod +x AppDir/AppRun

      - name: Fix RPATH for all binaries and libraries
        run: |
          # Fix RPATH for main executable
          patchelf --set-rpath '$ORIGIN/../lib' AppDir/usr/bin/${PROJECT_NAME} || true

          # Fix RPATH for clang++ to find its libraries
          if [ -f "AppDir/usr/bin/clang++" ]; then
            patchelf --set-rpath '$ORIGIN/../lib/clang-libs:$ORIGIN/../lib' AppDir/usr/bin/clang++ || true
          fi

          # Fix RPATH for all libraries
          find AppDir/usr/lib -name "*.so*" -type f -exec \
            patchelf --set-rpath '$ORIGIN' {} \; 2>/dev/null || true

      ################### create AppImage ###################
      - name: Download appimagetool
        run: |
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage

      - name: Create AppImage
        run: |
          # Use --appimage-extract-and-run to work without FUSE in CI environment
          # Set ARCH explicitly to avoid architecture detection issues
          ARCH=x86_64 ./appimagetool-x86_64.AppImage --appimage-extract-and-run AppDir ${PROJECT_NAME}-x86_64.AppImage
          chmod +x ${PROJECT_NAME}-x86_64.AppImage

      ################### artifacts ###################
      - name: Upload AppImage artifact
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-AppImage
          path: ${{ env.PROJECT_NAME }}-x86_64.AppImage

      - name: Export AppImage outside container (act only)
        if: ${{ env.ACT }}
        run: |
          mkdir -p /github/workspace/out
          cp ${PROJECT_NAME}-x86_64.AppImage /github/workspace/out/

      ################### release upload ###################
      - name: Upload AppImage to GitHub Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ env.PROJECT_NAME }}-x86_64.AppImage
